<!DOCTYPE html>
<html lang="en">
  <head>
      <meta charset="utf-8">
      <link href="https://fonts.googleapis.com/css?family=VT323&display=swap" rel="stylesheet">
      <title>UFO Shape/Appearance</title>
      <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

      <style>
        body {
          font-family: "VT323";
          line-height: 160%;
          font-size: 16px;
          margin: 0;
          color: white;
        }
        path.link {
          fill: none;
          stroke-width: 2px;
        }
        .node:not(:hover) .nodetext {
          display: none;
        }
        h1 { font-size: 30px; margin: 5px 0; text-transform: uppercase; font-weight: normal;}
        h2, h3 { font-size: 20px; margin: 2px 0 ; font-weight: normal;}
        header {padding: 20px; position: absolute; top: 0; left: 0;}
        a:link { color: #EE3124; text-decoration: none;}
        a:visited { color: #EE3124; }
        a:hover { color: #A4CD39; text-decoration: underline;}
        a:active { color: #EE3124; }
      </style>
  </head>


  <body>
      <header>
        <h1>UFOs are like...</h1>
        <h2>Shape/Appearance?</h2>
        <h3>Click to view their count</h3>
      </header>
      <!-- container for force layout visualisation  -->
      <section id="vis"></section>
    <script>

        // some colour variables
          var tcBlack = "#ffffff";

        // rest of vars
        var w = 530,
            h = 450,
            maxNodeSize = 50,
            x_browser = 20,
            y_browser = 25,
            root;

        var vis;
        var force = d3.layout.force();

        vis = d3.select("#vis").append("svg").attr("width", w).attr("height", h);

        d3.json("ufo-sightings/ufo.json", function(json) {

          root = json;
          root.fixed = true;
          root.x = w / 2;
          root.y = h / 2;


          // Build the path
          var defs = vis.insert("svg:defs")
              .data(["end"]);


          defs.enter().append("svg:path")
              .attr("d", "M0,-5L10,0L0,5");

            update();
        });


        function update() {
          var nodes = flatten(root),
              links = d3.layout.tree().links(nodes);

          // Restart the force layout.
          force.nodes(nodes)
                .links(links)
                .gravity(0.05)
                .charge(-1500)
                .linkDistance(50)
                .friction(0.5)
                .linkStrength(function(l, i) {return 1; })
                .size([w, h])
                .on("tick", tick)
                .start();

          var path = vis.selectAll("path.link")
              .data(links, function(d) { return d.target.id; });

            path.enter().insert("svg:path")
              .attr("class", "link")
              // .attr("marker-end", "url(#end)")
              .style("stroke", "#eee");


          // Exit any old paths.
          path.exit().remove();



          // Update the nodesâ€¦
          var node = vis.selectAll("g.node")
              .data(nodes, function(d) { return d.id; });


          // Enter any new nodes.
          var nodeEnter = node.enter().append("svg:g")
              .attr("class", "node")
              .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
              .on("click", click)
              .call(force.drag);

          // Append a circle
          nodeEnter.append("svg:circle")
              .attr("r", function(d) { return Math.sqrt(d.size) / 100 || 4.5; })
              .style("fill", "#eee");


          // Append images
          var images = nodeEnter.append("svg:image")
                .attr("xlink:href",  function(d) { return d.img;})
                .attr("x", function(d) { return -d.area/2;})
                .attr("y", function(d) { return -d.area/2;})
                .attr("height", function(d) { return d.area;})
                .attr("width", function(d) { return d.area;});

          // make the image grow a little on mouse over and add the text details on click
          var setEvents = images
                  // Append ufo text
                  .on( 'click', function (d) {
                      d3.select("h1").html(d.shape);
                      d3.select("h2").html(d.name);
                      d3.select("h3").html("Count: " + "<a>"  + d.count + "</a>" );
                  })

                  .on( 'mouseenter', function() {
                    // select element in current context
                    d3.select( this )
                      .transition()
                      .attr("x", function(d) { return -42;})
                      .attr("y", function(d) { return -42;})
                      .attr("height", 70)
                      .attr("width", 70);
                  })
                  // set back
                  .on( 'mouseleave', function() {
                    d3.select( this )
                      .transition()
                      .attr("x", function(d) { return -d.area/2;})
                      .attr("y", function(d) { return -d.area/2;})
                      .attr("height", function(d) { return d.area;})
                      .attr("width", function(d) { return d.area;});
                  });

          // Append ufo name on roll over next to the node as well
          nodeEnter.append("text")
              .attr("class", "nodetext")
              .attr("x", x_browser)
              .attr("y", y_browser +15)
              .attr("fill", tcBlack)
              .text(function(d) { return d.shape; });


          // Exit any old nodes.
          node.exit().remove();


          // Re-select for update.
          path = vis.selectAll("path.link");
          node = vis.selectAll("g.node");

        function tick() {


            path.attr("d", function(d) {

            var dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = Math.sqrt(dx * dx + dy * dy);
                  return   "M" + d.source.x + ","
                    + d.source.y
                    + "A" + dr + ","
                    + dr + " 0 0,1 "
                    + d.target.x + ","
                    + d.target.y;
          });
            node.attr("transform", nodeTransform);
          }
        }


        /**
        * Gives the coordinates of the border for keeping the nodes inside a frame
        * http://bl.ocks.org/mbostock/1129492
        */
        function nodeTransform(d) {
          d.x =  Math.max(maxNodeSize, Math.min(w - (d.imgwidth/2 || 16), d.x));
            d.y =  Math.max(maxNodeSize, Math.min(h - (d.imgheight/2 || 16), d.y));
            return "translate(" + d.x + "," + d.y + ")";
          }

        /**
        * Toggle children on click.
        */
        function click(d) {
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }

          update();
        }


        /**
        * Returns a list of all nodes under the root.
        */
        function flatten(root) {
          var nodes = [];
          var i = 0;

          function recurse(node) {
            if (node.children)
              node.children.forEach(recurse);
            if (!node.id)
              node.id = ++i;
            nodes.push(node);
          }

          recurse(root);
          return nodes;
        }


    </script>

  </body>
</html>
